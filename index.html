<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Write GTK applications using Rust</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/dist/reset.css">
  <link rel="stylesheet" href="reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="reveal.js/plugin/highlight/zenburn.css" />
  <style>
    pre code {
      font-size: 14px;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }

    .side-by-side {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-flow: row;
      transform: translateX(-10%);
    }

    .side {
      flex-grow: 1;
    }

    .side.figure-side {
      flex-shrink: 0;
    }
  </style>
  <link rel="stylesheet" href="reveal.js/dist/theme/beige.css" id="theme">
</head>

<body>
  <div class="reveal">
    <div class="slides">


      <section id="writing-applications-using-gtk-4-rust" class="slide level1">
        <h2>Writing applications using GTK 4 &amp; Rust</h2>
        <div style="display:flex;flex-direction: row; justify-content:center;">
          <div>
            <img width="120px" height="120px" src="https://upload.wikimedia.org/wikipedia/commons/7/71/GTK_logo.svg" />
          </div>
          <div>
            <img width="120px" height="120px" src="https://rustacean.net/assets/rustacean-orig-noshadow.svg" />
          </div>
        </div>
        <div style="font-size: 14px; text-align: right;">
          Source: <a
            href="https://github.com/bilelmoussaoui/something-somewhere-nothing">https://github.com/bilelmoussaoui/something-somewhere-nothing</a>
          <br />
          Slides: <a
            href="https://bilelmoussaoui.github.io/something-somewhere-nothing">https://bilelmoussaoui.github.io/something-somewhere-nothing</a>
        </div>
      </section>

      <section id="introduction" class="slide level2">
        <h3>Introduction</h3>
        <ul class="fragment">
          <li>GTK is a user interface toolkit</li>
          <li>Built using C, following object-oriented design pattern thanks to GLib/GObject</li>
        </ul>
        <div class="fragment">
          <ul>
            <li>The bindings are partially generated from gobject introspection data thanks to girÂ¹</li>
            <li>Manual code is needed for cases like subclassing support</li>
          </ul>

          <small style="margin-top:60px;margin-right: 620px;">
            <ol>
              <li>
                <a href="https://github.com/gtk-rs/gir">https://github.com/gtk-rs/gir</a>
              </li>
            </ol>
          </small>
        </div>
      </section>

      <section>
        <section>
          <h3>Subclassing support</h3>
          <div class="fragment">
            <ul>
              <li>GLib Rust bindings contains the base code for creating custom GObjects, e.g subclassing.
                <small style="margin-top: 20px;margin-bottom: 20px;">
                  <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/subclass">See https:
                    //gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/subclass for details</https:>
                  </a>
                </small>
              </li>
              <li class="fragment">
                Thanks to the simplifications of creating custom widgets in GTK 4, the Rust bindings provides almost
                complete subclassing support
              </li>
            </ul>
          </div>
        </section>

        <section>
          <p>Let's see how we can create a custom glib::Object</p>
          <pre class="fragment" lang="rust">
            <code data-trim data-noescape data-line-numbers="5-6|8-13|14|3-15|17-19|21-25">
              <script type="text/template">

            use glib::subclass:prelude::*;

            mod imp {
                use super::*;
                #[derive(Default)]
                pub struct SomeObject;

                #[glib::object_subclass]
                impl ObjectSubclass for SomeObject {
                    const NAME: &'static str = "SomeObject";
                    type Type = super::SomeObject;
                    type ParentType = glib::Object;
                }
                impl ObjectImpl for SomeObject {}
            }

            glib::wrapper! {
                pub struct SomeObject(ObjectSubclass<imp::SomeObject>);
            }

            impl SomeObject {
                pub fn new() -> Self {
                    glib::Object::new(&[]).unwrap()
                }
            }

              </script>
            </code>
          </pre>
        </section>

        <section>
          <p>What if we want to create a custom <code>gtk::Widget</code>?
          </p>
          <pre class="fragment" lang="rust">
            <code data-trim data-noescape data-line-numbers="13,16,20">
              <script type="text/template">

            use gtk::subclass:prelude::*;
            use gtk::glib;

            mod imp {
                use super::*;
                #[derive(Default)]
                pub struct CustomWidget;

                #[glib::object_subclass]
                impl ObjectSubclass for CustomWidget {
                    const NAME: &'static str = "CustomWidget";
                    type Type = super::CustomWidget;
                    type ParentType = gtk::Widget;
                }
                impl ObjectImpl for CustomWidget {}
                impl WidgetImpl for CustomWidget {}
            }

            glib::wrapper! {
                pub struct CustomWidget(ObjectSubclass<imp::CustomWidget>) @extends gtk::Widget;
            }

            impl CustomWidget {
                pub fn new() -> Self {
                    glib::Object::new(&[]).unwrap()
                }
            }
              </script>
            </code>
          </pre>
        </section>

        <section>
          <p>We can override functions that changes a behavior. They are called virtual functions</p>

          <pre class="fragment" lang="rust">
            <code data-trim data-noescape data-line-numbers="23-28">
              <script type="text/template">

          use gtk::prelude::*;
          use gtk::subclass::prelude::*;
          use gtk::{gdk, glib, graphene};

          mod imp {
              use super::*;
              #[derive(Default)]
              pub struct CustomWidget;

              #[glib::object_subclass]
              impl ObjectSubclass for CustomWidget {
                  const NAME: &'static str = "CustomWidget";
                  type Type = super::CustomWidget;
                  type ParentType = gtk::Widget;
              }
              impl ObjectImpl for CustomWidget {
                  fn constructed(&self, obj: &Self::Type) {
                      obj.set_width_request(40);
                      obj.set_height_request(40);
                  }
              }
              impl WidgetImpl for CustomWidget {
                  fn snapshot(&self, widget: &Self::Type, snapshot: &gtk::Snapshot) {
                      snapshot.append_color(
                          &gdk::RGBA::black(),
                          &graphene::Rect::new(0.0, 0.0, widget.width() as f32, widget.height() as f32),
                      );
                  }
              }
          }

          glib::wrapper! {
              pub struct CustomWidget(ObjectSubclass<imp::CustomWidget>) @extends gtk::Widget;
          }

          impl CustomWidget {
              pub fn new() -> Self {
                  glib::Object::new(&[]).unwrap()
              }
          }
              </script>
            </code>
          </pre>
          <p class="fragment">
            By overriding snapshot, we tell the renderer how our widget should be displayed
          </p>
        </section>

        <section>
          <p>Let's see how our widget looks like</p>
          <div class="side-by-side fragment">
            <div class="side">
              <pre lang="rust">
                <code data-trim data-noescape data-line-numbers="19-22">
                  use gtk::prelude::*;

                  mod custom_widget;
                  use crate::custom_widget::CustomWidget;

                  fn main() {
                      let application = gtk::Application::builder()
                          .application_id("org.guadec.talk.rust")
                          .build();

                      application.connect_activate(|app| {
                          let window = gtk::ApplicationWindow::builder()
                              .application(app)
                              .default_width(350)
                              .default_height(350)
                              .title("Custom Widget")
                              .build();

                          let custom_widget = CustomWidget::new();
                          window.set_child(Some(&custom_widget));

                          window.show();
                      });

                      application.run();
                  }
        
                  </code>
                </pre>
            </div>
            <div class="side figure-side">
              <figure>
                <img src="assets/subclassing-demo-1.png" />
              </figure>
            </div>
          </div>
        </section>

        <section>
          <p>
            What if we wanted to make the rendered color based on a property
          </p>

          <pre class="fragment" lang="rust">
            <code data-trim data-noescape data-line-numbers="13|23-34|36-41|43-50">
              <script type="text/template">

        use gtk::prelude::*;
        use gtk::subclass::prelude::*;
        use gtk::{gdk, glib, graphene};
        
        mod imp {
            use super::*;
            use glib::{ParamSpec, Value};
            use once_cell::sync::Lazy;
            use std::cell::RefCell;
        
            #[derive(Default)]
            pub struct CustomWidget {
                rgba: RefCell<Option<gdk::RGBA>>,
            }
        
            #[glib::object_subclass]
            impl ObjectSubclass for CustomWidget {
                const NAME: &'static str = "CustomWidget";
                type Type = super::CustomWidget;
                type ParentType = gtk::Widget;
            }
            impl ObjectImpl for CustomWidget {
                fn properties() -> &'static [ParamSpec] {
                    static PROPS: Lazy<Vec<ParamSpec>> = Lazy::new(|| {
                        vec![ParamSpec::new_boxed(
                            "rgba",
                            "RGBA",
                            "Color RGBA",
                            gdk::RGBA::static_type(),
                            glib::ParamFlags::READWRITE,
                        )]
                    });
                    PROPS.as_ref()
                }
        
                fn property(&self, _obj: &Self::Type, _id: usize, pspec: &ParamSpec) -> Value {
                    match pspec.name() {
                        "rgba" => self.rgba.borrow().to_value(),
                        _ => unimplemented!(),
                    }
                }
        
                fn set_property(&self, _obj: &Self::Type, _id: usize, value: &Value, pspec: &ParamSpec) {
                    match pspec.name() {
                        "rgba" => {
                            self.rgba.borrow_mut().replace(value.get().unwrap());
                        }
                        _ => unimplemented!(),
                    }
                }
        
                fn constructed(&self, obj: &Self::Type) {
                    obj.set_width_request(40);
                    obj.set_height_request(40);
                }
            }
            impl WidgetImpl for CustomWidget {
                fn snapshot(&self, widget: &Self::Type, snapshot: &gtk::Snapshot) {
                    let color = self.rgba.borrow().unwrap_or_else(|| gdk::RGBA::black());
                    snapshot.append_color(
                        &color,
                        &graphene::Rect::new(0.0, 0.0, widget.width() as f32, widget.height() as f32),
                    );
                }
            }
        }
        
        glib::wrapper! {
            pub struct CustomWidget(ObjectSubclass<imp::CustomWidget>) @extends gtk::Widget;
        }
        
        impl CustomWidget {
            pub fn new() -> Self {
                glib::Object::new(&[]).unwrap()
            }
        }
              </script>
            </code>
          </pre>
        </section>

        <section>
          <p>Let's see how our widget looks like</p>
          <div class="side-by-side fragment">
            <div class="side">
              <pre lang="rust">
                <code data-trim data-noescape data-line-numbers="22-24">
                  use gtk::gdk;
                  use gtk::prelude::*;
                  use std::str::FromStr;

                  mod custom_widget;
                  use crate::custom_widget::CustomWidget;

                  fn main() {
                      let application = gtk::Application::builder()
                          .application_id("org.guadec.talk.rust")
                          .build();

                      application.connect_activate(|app| {
                          let window = gtk::ApplicationWindow::builder()
                              .application(app)
                              .default_width(350)
                              .default_height(350)
                              .title("Custom Widget")
                              .build();

                          let custom_widget = CustomWidget::new();
                          custom_widget
                              .set_property("rgba", &gdk::RGBA::from_str("#cc9393").unwrap())
                              .unwrap();
                          window.set_child(Some(&custom_widget));

                          window.show();
                      });

                      application.run();
                  }

                  </code>
                </pre>
            </div>
            <div class="side figure-side">
              <figure>
                <img src="assets/subclassing-demo-2.png" />
              </figure>
            </div>
          </div>
        </section>
      </section>

      <section>
        <section>
          <h3>Composite Templates</h3>
          <ul>
            <li class="fragment">Allows splitting code into model/view</li>
            <li class="fragment">More stuff here maybe?</li>
          </ul>
        </section>
        <section>
          <p>Before continuing forward, let's try to modify the subclassing example to add a label that
            display the HEX color</p>
          <div class="side-by-side fragment">
            <div class="side">
              <pre lang="rust">
                <code data-trim data-noescape data-line-numbers="13|62-76|80-98|107">
                  <script type="text/template">
          use gtk::prelude::*;
          use gtk::subclass::prelude::*;
          use gtk::{gdk, glib, graphene};

          mod imp {
              use super::*;
              use glib::{ParamSpec, Value};
              use once_cell::sync::Lazy;
              use std::cell::RefCell;

              pub struct CustomWidget {
                  rgba: RefCell<Option<gdk::RGBA>>,
                  label: gtk::Label,
              }

              impl Default for CustomWidget {
                  fn default() -> Self {
                      Self {
                          rgba: RefCell::default(),
                          label: gtk::Label::new(None),
                      }
                  }
              }

              #[glib::object_subclass]
              impl ObjectSubclass for CustomWidget {
                  const NAME: &'static str = "CustomWidget";
                  type Type = super::CustomWidget;
                  type ParentType = gtk::Widget;
              }

              impl ObjectImpl for CustomWidget {
                  fn properties() -> &'static [ParamSpec] {
                      static PROPS: Lazy<Vec<ParamSpec>> = Lazy::new(|| {
                          vec![ParamSpec::new_boxed(
                              "rgba",
                              "RGBA",
                              "Color RGBA",
                              gdk::RGBA::static_type(),
                              glib::ParamFlags::READWRITE,
                          )]
                      });
                      PROPS.as_ref()
                  }

                  fn property(&self, _obj: &Self::Type, _id: usize, pspec: &ParamSpec) -> Value {
                      match pspec.name() {
                          "rgba" => self.rgba.borrow().to_value(),
                          _ => unimplemented!(),
                      }
                  }

                  fn set_property(&self, _obj: &Self::Type, _id: usize, value: &Value, pspec: &ParamSpec) {
                      match pspec.name() {
                          "rgba" => {
                              self.rgba.borrow_mut().replace(value.get().unwrap());
                          }
                          _ => unimplemented!(),
                      }
                  }

                  fn constructed(&self, obj: &Self::Type) {
                      self.label.set_parent(obj);
                      self.label.add_css_class("title-1");

                      obj.bind_property("rgba", &self.label, "label")
                          .transform_to(move |_, val| {
                              let rgba = val.get::<gdk::RGBA>().unwrap();
                              Some(rgba.to_string().to_value())
                          })
                          .build();
                  }

                  fn dispose(&self, _obj: &Self::Type) {
                      self.label.unparent();
                  }
              }

              impl WidgetImpl for CustomWidget {
                  fn measure(
                      &self,
                      _widget: &Self::Type,
                      _orientation: gtk::Orientation,
                      _for_size: i32,
                  ) -> (i32, i32, i32, i32) {
                      (250, 250, -1, -1)
                  }

                  fn size_allocate(&self, _widget: &Self::Type, width: i32, height: i32, baseline: i32) {
                      self.label.size_allocate(
                          &gtk::Allocation {
                              x: 0,
                              y: 0,
                              width,
                              height,
                          },
                          baseline,
                      );
                  }

                  fn snapshot(&self, widget: &Self::Type, snapshot: &gtk::Snapshot) {
                      let color = self.rgba.borrow().unwrap_or_else(|| gdk::RGBA::black());
                      snapshot.append_color(
                          &color,
                          &graphene::Rect::new(0.0, 0.0, widget.width() as f32, widget.height() as f32),
                      );
                      widget.snapshot_child(&self.label, snapshot);
                  }
              }
          }

          glib::wrapper! {
              pub struct CustomWidget(ObjectSubclass<imp::CustomWidget>) @extends gtk::Widget;
          }

          impl CustomWidget {
              pub fn new() -> Self {
                  glib::Object::new(&[]).unwrap()
              }
          }
                  </script>
                </code>
              </pre>
            </div>
            <div class="fragment side figure-side">
              <figure>
                <img src="assets/subclassing-demo-3.png" />
              </figure>
            </div>
          </div>
        </section>
      </section>
      <section>
        <h3>Portals</h3>
      </section>
      <section>
        <h3>Ecosystem</h3>
        <ul>
          <li>gtk-rs-core: bindings of glib, gio, pango, cairo, graphene and gdk-pixbuf</li>
          <li>gstreamer-rs: bindings of the multimedia framework GStreamer</li>
          <li>zbus: Rust D-Bus crate</li>
          <li>ashpd: Freedesktop portals wrapper using zbus</li>
          <li class="fragment">also sourceview5-rs, pipewire-rs, libadwaita-rs, tracker-rs</li>
          <li class="fragment">and ton of other possibilities at crates.io</li>
        </ul>
      </section>
      <section>
        <h3>Resources</h3>
        <ul>
          <li>GUI development with Rust and GTK 4: <a
              href="https://gtk-rs.org/gtk4-rs/stable/latest/book/">https://gtk-rs.org/gtk4-rs/stable/latest/book/</a>
          </li>
          <li>Examples: <a
              href="https://github.com/gtk-rs/gtk4-rs/tree/master/examples#examples">https://github.com/gtk-rs/gtk4-rs/tree/master/examples</a>
          </li>
          <li>Built with gtk4-rs: <a
              href="https://github.com/gtk-rs/gtk4-rs#built-with-gtk4-rust-bindings">https://github.com/gtk-rs/gtk4-rs#built-with-gtk4-rust-bindings</a>
          </li>
          <li>Reach out: <a href="https://gtk-rs.org/contact">https://gtk-rs.org/contact</a>
          </li>
          </li>
        </ul>
      </section>
      <section>
        <h3>Thank you</h3>
      </section>
      <section>
        <h3>Any questions?</h3>
      </section>
    </div>
  </div>

  <script src="reveal.js/dist/reveal.js"></script>

  // reveal.js plugins
  <script src="reveal.js/plugin/notes/notes.js"></script>
  <script src="reveal.js/plugin/search/search.js"></script>
  <script src="reveal.js/plugin/markdown/markdown.js"></script>
  <script src="reveal.js/plugin/highlight/highlight.js"></script>
  <script>
    // Full list of configuration options available at:
    // https://revealjs.com/config/
    Reveal.initialize({
      // Push each slide change to the browser history
      history: true,
      slideNumber: true,
      keyboard: true,
      disableLayout: false,
      transition: 'fade',
      backgroundTransition: 'fade',

      // reveal.js plugins
      plugins: [
        RevealNotes,
        RevealSearch,
        RevealMarkdown,
        RevealHighlight,
      ]
    });
  </script>
</body>

</html>